---
layout:     post
title:      "Effective Objective-C"
subtitle:   ""
date:       2017-02-05 13:00:00
author:     "bigfacexml"
catalog: true
tags:
    - OC基础
---

## 一、熟悉Objective-C
#### 1. 了解Objective-C的起源
* Objective-C为C语言添加了面向对象的特性，是其超集。使用动态绑定的消息结构，运行时才会检查对象类型。接收一条消息后，究竟应执行何种代码，由运行期环境而非编译器决定；
* 尤其要掌握Objective-C语言的内存模型和指针；

#### 2. 在类的文件中尽量少引入其他头文件
* 为了不增加不必要的编译时间，降低类的耦合；
* 如果不需要类的接口细节，应在头文件中使用向前声明来提及别的类，在实现文件中引入那个类的头文件；
* 如果要遵循一项协议，协议尽量单独放在一个头文件中，然后在实现文件中头文件并通过class-continuation遵循该协议；

#### 3. 多用字面量语法，少用与之等价的方法
* 更加简明扼要；
* 应该通过去下标访问数组或字典
* 用字面量语法创建数组或字典是，若值中有nil，则会抛出异常，这样更方便查找问题

#### 4. 多用类型常量，少用#define预处理命令
* 预处理命令定义出来的常量不含类型信心，编译器只会在编译前执行查找与替换操作。即使有人重新定义常量值，编译器也不会产生警告；
* static const定义只在编译单元内可见的常量。定义基础类型 static const int k = 0; 定义指针类型对象 NSString * static const str; (const要修饰变量名表示常量指针)
* 在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。extern NSString * const str; NSString * const str=@"";

#### 5.用枚举表示状态、选项、状态码。NS_ENUM, NS_OPTIONS

## 二、对象、消息、运行期
#### 6. 理解“属性”这一概念
* 自动创建存取方法；
* 属性特质要掌握，读写权限、内存管理语义；
* 开发iOS程序时应该使用nonatomic属性，因为atomic会严重影响性能；

#### 7. 在对象内部尽量直接访问实例变量
* 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应通过属性来写。这样做既能提高读取操作的速度，又能控制对属性的写入操作；
* 在初始化方法及dealloc方法中，总是应该直接通过实例变量来读写数据。因为子类可能重载读写方法；
* 有时会惰性初始化(Lazy initialization)，这种情况下需要通过属性来读取数据；

#### 8. 理解对象等同性这一概念
* 若想检测对象的等同性，请提供"isEqual"与hash方法

#### 9. 以“类族模式”隐藏实现细节
* 采用了工厂模式，抽象基类
* 类族模式可以把实现细节隐藏在一套简单的公共接口后面；

#### 10. 在既有类中使用关联对象存放自定义数据
* 给对象动态添加属性 objc_setAssociatedObject / objc_getAssociateObject
* 可以通过“关联对象”机制把两个对象连起来，比如把对象与回调方法block关联起来，就能在定义对象的附近定义block并关联起来；
* 这种做法通常会引入难于查找的bug，所以慎用；

#### 11. 理解objc_msgSend的作用
* 消息由接收者、选择子、及参数构成。给某对象“发送消息”，也就相当于在该对象上调用方法；
* 发送某消息的全部消息都要由“动态消息派发系统”来处理，该系统会查出对应的方法，并执行其代码；

#### 12. 理解消息转发机制
* 若对象无法响应某个选择子，则进入消息转发流程；
* 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中；
* 对象可以把其无法解读的某些选择子转交给其他对象来处理；
* 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制；

#### 13. 用方法调配技术调试黑盒方法
* method swizzling；
* 在运行期，可以向类中新增或替换选择子所对应的方法实现；
* 适合用于调试，对某个方法进行hook，`method_exchangeImplementations(m1, m2)`

#### 14. 理解”类对象“的用意
* 每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系；
* 如果对象类型无法再编译期确定，那么就该使用类型信息查询方法来探知；(isMemberOfClass, isKindOfClass)
* 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发机制；
* 类对象所属的类型（isa指针指向）是另外一个类，叫做”元类“，用来表述类对象本身所具备的元数据。类方法就定义于此；

## 三、接口与API设计
#### 15. 用前缀避免命名空间冲突
* 要选择与你公司、应用程序或二者相关联的名称作为类名的前缀，并在所有代码中均使用这一前缀；
* 若自己开发的程序库中使用了第三方库，则应为其中的名称加上前缀

#### 16. 提供`全能初始化方法`
* 在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法；
* 若全能初始化方法与超类不同，则需覆写超类中的对应方法；
* 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常；

#### 17. 实现`description`方法
* 实现description方法返回一个有意义的字符串，用以描述该实例；
* 若想在调试时打印出更详尽的对象描述信息，则应实现`debugDescription`方法；

#### 18. 尽量使用不可变对象
* 尽量创建不可变对象
* 若某属性仅可于对象内部修改，则在`class-continuation`分类中将其由readonly属性扩展为readwrite属性；
* 不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection；

#### 19. 使用清晰而协调的命名方式
* 起名时应遵从Objective-C的命名规范，这样创建出来的接口更容易为开发者所理解；
* 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好；
* 方法名里不要使用缩略后的类型名称；比如`str`，应用`string`；
* 给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符；

#### 20. 为私有方法名加前缀
* `p_privateMethod`，这类风格，可以很容易将其与公共方法区分开；
* 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的；

#### 21. 理解Objective-C错误模型
* Objective-C语言现在所采用的办法是：只在及其罕见的情况下抛出异常，异常抛出之后，无需考虑恢复问题，而且应用程序此时也应该退出；
* 捕获异常可能导致ARC模式下的内存泄露，所以慎用；
* 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常；
* 在错误不那么严重情况下可以指派委托方法（`delegate method`）来处理错误，也可以把错误信息放在NSError对象里，经由“输出参数”反馈给调用者；

#### 22. 理解NSCopying协议
* 如果想令自己的类支持拷贝操作，就要实现NSCopying协议，并提供方法`- (id)copyWithZone:(NSZone *)zone`;这里的参数zone，是因为以前开发程序需要把内存分成不同的区（zone），对象会被创建在某个zone里面。现在不需要指定zone了，因为每个程序都只有一个默认zone；
* 类似于序列化对象的NSCoding协议，提供`initWithCoder`和`encodeWithCoder`方法；
* 深拷贝与浅拷贝
* 如果自定义的对象分为可变版本与不可变版本，那就要同时实现NSCopying与NSMutableCopying协议；
* 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法

## 四、协议与分类
#### 23. 通过委托与数据源协议进行对象间通信
* 使用委托进行对象间通信，为了不阻塞UI线程，在获取完数据后再回调委托对象进行页面数据刷新；
* delegate属性需定义成weak；
* 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象；
* 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法；
* 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情况下，该模式亦称“数据源协议”（data source protocol);
* 若有必要，可实现含有位段的结构体，将委托对象是否能相应相关协议方法这一信息进行缓存；


#### 24. 将类的实现代码分散到便于管理的数个分类中
* 使用分类Category机制把类的实现代码划分成易于管理的小块；
* 将应该视为“私有”的方法归入名叫Private的分类中，以隐藏实现细节；

#### 25. 总是为第三方类的分类名称加前缀
* 为了避免和第三方类里的分类或方法重名。如果那个分类的加载时机晚于你所写的分类，那么你的代码就会被覆盖掉（不过编译器貌似会提醒）；
* 向第三方类中添加分类时，总应给其名称加上你专用的前缀。方法名也应加上前缀；

#### 26. 勿在分类中声明属性
* 把封装数据所用的全部属性都定义在主接口里；
* 在Class-Continuation分类之外的其他分类中，可以定义存取方法，但尽量不要定义属性；

#### 27. 使用class-continuation分类隐藏实现细节
* 其实就是常用的在实现文件里@interface MyClass()这样；
* 把细节隐藏起来，只供本类使用；
* 在头文件中只读，在class-continuation中扩展为可读写；
* 通过class-continuation分类向类中新增实例变量；
* 把私有方法的原型声明在class-continuation分类里，也可以不声明；
* 若想使类所遵循的协议 不为人知，则可于class-continuation分类中声明；

#### 28. 通过协议提供匿名对象
* 不是匿名内部类的意思（block有这样的作用）；
* 例如,返回类型id<DatabaseConnection>，处理数据库连接所用的类的名称就不会泄露了，设计API的时候也都可以通过这个方法处理数据库连接对象；
* 协议可在某种程度上提供匿名类型。具体的类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法；
* 如果具体类型不重要，重要的是对象能够响应特定方法，那么可以使用匿名对象来表示；

## 五、内存管理

#### 29. 理解引用计数
* 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数将为0时，对象就被销毁了；
* 对象生命期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数；

#### 30. 以ARC简化引用计数
* 若方法名以`alloc` `new` `copy` `mutableCopy` 开头，则其返回的对象归调用者所有，引用计数为1；
* 有ARC之后，程序员就无须担心内存管理的问题了。使用ARC编程，可省去类中的许多“样板代码”；
* 在ARC环境下，变量的内存管理语义可以通过修饰符进行指明，而原来则需要手工执行“保留”及“释放”操作；
* 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则；
* ARC只负责管理OC对象的内存。尤其要注意：CoreFoundation对象将不归ARC管理，开发者必须适时调用CFRetain/CFRelease;

#### 31. 在dealloc方法中只释放引用并解除监听；
* 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的`KVO`或`NSNotificationCenter`通知，不要做其他事情；
* 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法；
* dealloc方法不一定会执行，不调用dealloc方法时为了优化程序效率（应用程序终止时，其占用的资源全部返还给系统），所以清理方法应该要有专门close方法而非dealloc中清理资源，比如关闭socket连接或数据库连接；
* 执行异部任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态栏了；
* 在dealloc里不要调用属性的存取方法，因为有人可能会覆写这些方法，并于其中做一些无法再回收阶段安全执行的操作；

#### 32. 编写“异常安全代码”时留意内存管理问题
* 捕获异常时，一定要注意将try块内创立的对象清理干净；
* 在默认情况下，ARC不生成安全粗粒异常所需的清理代码。开启编译器标志后（打开`-fobj-arc-exception`)，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率；
* 如何设置编译器标志？`Targets -> Build Phases -> Compile Sources`, 双击文件并输入编译器标志即可;

#### 33. 以若引用避免保留环
* 将某些引用设为weak，避免循环引用；
* weak引用可以自动清空，也可以不自动清空。自动清空是随着ARC而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种弱引用不会指向已经回收过的对象；

#### 34. 以“自动释放池块”降低内存峰值
* 自动释放池排布在栈中，对象收到autorelease后，系统将其放入最顶端的池里；
* 合理运用自动释放池，可降低应用程序的内存峰值；
* @autoreleasepool这种新式写法能创建出更为轻便的自动释放池；

#### 35. 用“僵尸对象”调试内存管理问题
* 系统在回收对象时，可以不将其真的回收，而是转化为僵尸对象，通过环境变量NSZoombieEnabled可开启此功能；（但是xcode占用内存会变大好多，在调试野指针问题时才应该开启）；

#### 36. 不要使用retainCount
* ARC已经将此方法废弃了，如果使用的话编译器直接报错；
* 对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留技术”都无法反应对象生命期的全貌；

## 六、块与大中枢派发
#### 37. 理解block这一概念
* block的强大之处是，在声明它的范围里，所有变量都可以为其所捕获；
* 默认情况下，为block所捕获的变量不可以在block里修改；添加__block修饰符可使得变量在block内修改；（注意对象是可以捕获到并可修改的，如self）
* block也可以理解为一个对象，会执行一段代码，类似一个方法；
* block是C, C++, Objective-C中的词法闭包（closure，匿名内部类）；
* block可接受参数，也可返回值；
* block可以分配在栈或堆上，也可以是全局的。分配在栈上的可以拷贝到堆里，这样的话就和标准的OC对象一样了，具备引用计数；

#### 38. 为常用的block类型创建typedef
* 以typedef重新定义block类型，可令block变量用起来更加简单；
* 定义新类型时应遵从现有的命名习惯
* 不妨为同一个block签名定义多个类型别名，如果要重构的代码使用了block的某个别名，就只需要修改相应的typedef中的block块签名即可。无须改动其他typedef；

#### 39.用handler降低代码分散程度
* 在创建对象时，可以使用内联的handler块将相关业务逻辑一并声明；
* 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用handler实现，则可直接将block与相关对象放在一起；
* 设计API时如果用到了handler块，那么可以增加一个参数，调用者可通过此参数来决定应该把block安排在哪个队列上执行；

#### 40. 在block引用其所属对象时不要出现保留环
* 如果block所捕获的对象直接或间接地保留了block本身，那么就得当心循环引用问题；
* 一定要找个适当时机接触保留环，而不能把责任推给API的调用者；

#### 41. 多用派发队列，少用同步锁
* dispatch_sync, dispatch_async
* 派发队列可用来表达同步语义，币使用@synchronized或NSLock对象更简单；
* 将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程；
* 使用同步队列及栅栏block，可以令同步行为更加高效；

#### 42. 多用GCD，少用performSelector系列方法
* performSelector系列方法在内存管理方面容易有疏。无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法；
* performSelector系列方法所能处理的selector太过局限了，选择子的返回值类型及发送给方法的参数个数都受限制；
* 如果想把任务放在另一个线程上执行，那么最好不要用performSelector系列方法，而是应该把任务封装在block里，然后调用GCD的相关方法来实现；

#### 43. 掌握GCD及操作队列的使用实际
* 操作队列`NSOperationQueue`，在解决多线程与任务管理问题时，派发队列并非唯一方案；
* 操作队列提供了一套高层的OC API，能实现纯GCD所具备的绝大部分功能。而且能完成一些更加复杂的操作：取消某个操作、指定操作间的以来关系、通过KVO监控对象属性（isFinished, isCanceled)、指定操作优先级、重用NSOperation对象等；

#### 44. 通过`Dispatch Group`机制，根据系统资源状况来执行任务
* 一系列任务可归入一个`dispatch group`之中，开发者可以在这组任务执行完毕时获得通知，`dispatch_group_notify`函数可实现；
*  通过dispatch_group，可以在并发式派发队列里同时执行多项任务，此时GCD会根据系统资源状况来调度任务。

#### 45. 使用dispatc_once来执行只需运行一次的线程安全代码
* 原子操作，只执行一次，线程安全、更高效；
* 标记`dispatch_once_t`应该生命在static或global作用域中，这样的话，在把只需执行一次的block传给dispatch_once函数时，传进去的标记也是相同的；

#### 46. 不要使用`dispatch_get_current_queue`
* dispatch_get_current_queue函数的行为常常与预期不同。此函数已废弃，只做调试用；
* 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念；
* dispatch_get_current_queue函数用于解决由于不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决；（在当前队列上同步执行一个新任务，就会引发死锁，原因是不可重入的代码）；

## 七、系统框架
#### 47. 熟悉系统框架
* Foundation与CoreFoundation的无缝桥接;
* CFNetWork, CoreAudio, AVFoundation, CoreData, CoreText;

#### 48. 多用block枚举，少用for循环
* for循环，遍历dictionary或set比较麻烦，会增加额外开销；代码简单；
* 枚举类NSEnumerator，不能获取当前下标；可反向遍历；
* 快速遍历for..in，简单效率高，但对于dictionary还是不便；不能获取当前下标；继承自NSEnumerator类；
* 基于block的遍历方式，够强大；
* block枚举法本身就能通过GCD并发执行遍历操作；

#### 49. 对自定义其内存管理语义的collection使用无缝桥接
* 例如，NSArray -> CFArrayRef；
* 在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应该如何处理其元素。然后通过无缝桥接技术，将其转换成具备特殊内存管理语义的OC collecion；

#### 50. 构建缓存是选用NSCache而非NSDictionary
* NSCache具备自动删减功能，而且是线程安全的；此外，它与NSDictionary不同，并不会拷贝键；
* 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据功能，也就是说当NSPurgeableData对象所占内存被系统丢弃时，该对象本身也将从缓存中移除；

#### 51. 精简initialize与load的实现代码
* 在load方法中使用其他类是不安全的；因为不知道系统加载类的顺序，使用别的类的时候可能还没有加载该类；
* initialize方法在程序首次用该类之前调用，且只调用一次；
* load和initialize精简一些，有助于保持应用程序的响应能力；
* 无法再编译器设定的全局常亮，可以在initialize方法里初始化；

#### 52. 别忘了NSTimer会保留目前对象
* repeat的Timer记得invalidate；
* NSTimer会保留其目标targer，知道计时器失效为止；
* 可以扩充NSTimer功能，用block来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中；引入中间者block，设置weak引用，三者之前就不会出现保留换了；